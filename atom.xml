<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>红尘漫步</title>
  <subtitle>爱吃鱼的小强</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-26T01:56:13.956Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Justin Zhou</name>
    <email>13912926126@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>下载（2G以上）大文件支持小记</title>
    <link href="http://yoursite.com/2016/08/24/%E4%B8%8B%E8%BD%BD%EF%BC%882G%E4%BB%A5%E4%B8%8A%EF%BC%89%E5%A4%A7%E6%96%87%E4%BB%B6%E6%94%AF%E6%8C%81%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/08/24/下载（2G以上）大文件支持小记/</id>
    <published>2016-08-24T02:30:40.651Z</published>
    <updated>2016-08-26T01:56:13.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近项目中遇到了下载大文件（大于2G）失败的问题。查看了代码之后发现从一开始实现的时候就没有考虑对大文件的支持<i class="fa fa-frown-o"></i>。老板追的紧，没办法只能硬着头皮上。整个的解决过程就好像打怪升级一般，一步一个脚印。</p>
<h2 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a><strong>Round 1</strong></h2><h3 id="下载文件size每次都是2G"><a href="#下载文件size每次都是2G" class="headerlink" title="下载文件size每次都是2G"></a>下载文件size每次都是2G</h3><p>为什么每次下载的文件都是2G，明明在server端的文件是大于2G的。通过调试发现原来在下载的代码实现中，一些基本变量的定义都是int类型的，也就是说最大只能存储 $2^{31}-1$ 的正整数。所以需要将这些有影响的变量类型改为范围更大的类型。考虑到项目是多平台程序，所以参考了一下ANSI C/C++的基本数据类型：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th style="text-align:center">Size</th>
<th style="text-align:left">数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>无值型void</td>
<td style="text-align:center">0 byte</td>
<td style="text-align:left">无值域</td>
</tr>
<tr>
<td>布尔型bool</td>
<td style="text-align:center">1 byte</td>
<td style="text-align:left">true   false</td>
</tr>
<tr>
<td>有符号短整型short [int] /signed short [int]</td>
<td style="text-align:center">2 byte</td>
<td style="text-align:left">-32768~32767</td>
</tr>
<tr>
<td>无符号短整型unsigned short [int]</td>
<td style="text-align:center">2 byte</td>
<td style="text-align:left">0~65535</td>
</tr>
<tr>
<td>有符号整型int /signed [int]</td>
<td style="text-align:center">4 byte</td>
<td style="text-align:left">-2147483648~2147483647</td>
</tr>
<tr>
<td>无符号整型unsigned [int]</td>
<td style="text-align:center">4 byte</td>
<td style="text-align:left">0~4294967295</td>
</tr>
<tr>
<td>有符号长整型long [int]/signed long [int]</td>
<td style="text-align:center">4 byte</td>
<td style="text-align:left">-2147483648~2147483647</td>
</tr>
<tr>
<td>无符号长整型unsigned long [int]</td>
<td style="text-align:center">4 byte</td>
<td style="text-align:left">0~4294967295</td>
</tr>
<tr>
<td>有符号 long long</td>
<td style="text-align:center">8 byte</td>
<td style="text-align:left">-9223372036854775808~9223372036854775807</td>
</tr>
<tr>
<td>无符号long long</td>
<td style="text-align:center">8 byte</td>
<td style="text-align:left">0~18446744073709552000</td>
</tr>
<tr>
<td>有符号字符型char/signed char</td>
<td style="text-align:center">1 byte</td>
<td style="text-align:left">-128~127</td>
</tr>
<tr>
<td>无符号字符型unsigned char</td>
<td style="text-align:center">1 byte</td>
<td style="text-align:left">0~255</td>
</tr>
<tr>
<td>宽字符型wchar_t (unsigned short.)</td>
<td style="text-align:center">2 byte</td>
<td style="text-align:left">0~65535</td>
</tr>
<tr>
<td>单精度浮点型float</td>
<td style="text-align:center">4 byte</td>
<td style="text-align:left">-3.4E-38~3.4E+38</td>
</tr>
<tr>
<td>双精度浮点型double</td>
<td style="text-align:center">8 byte</td>
<td style="text-align:left">1.7E-308~1.7E+308</td>
</tr>
<tr>
<td>long double</td>
<td style="text-align:center">8 byte</td>
</tr>
</tbody>
</table>
<p>这里我们选用signed long long类型， 它可表示的最大的正整数是 $2^{63}-1$ ，足以应付4G的文件。增加如下定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> sint64_t_defined</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> sint64_t_defined</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">long</span>     Tsint64;<span class="comment">//It's illegal in C90. It's legel in C99. </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>接着把所有有影响的变量类型改为Tsint64。OK，第一关算是勉强通过了。</p>
<h2 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a><strong>Round 2</strong></h2><h3 id="检查文件size失败"><a href="#检查文件size失败" class="headerlink" title="检查文件size失败"></a>检查文件size失败</h3><p>通过前面的努力，终于可以将大于2G的文件下下来了。可是好景不长，程序走到检查文件size的时候fail了。手工检查了下文件的size是没有问题的，但是程序中获取的size是一个很奇怪的数。其中获取size的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">filelen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (fname == <span class="literal">NULL</span> || fname[<span class="number">0</span>] == <span class="string">'\0'</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	FILE *fp = fopen (fname, <span class="string">"rb"</span>);</div><div class="line">	<span class="keyword">if</span> (!fp)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	fseek (fp, <span class="number">0</span>, SEEK_END);</div><div class="line">	<span class="keyword">long</span> length = ftell (fp);</div><div class="line">	fclose (fp);</div><div class="line">	<span class="keyword">return</span> length == <span class="number">-1</span> ? <span class="number">0</span> : (<span class="keyword">unsigned</span> <span class="keyword">int</span>)length;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过调试发现问题出现在fseek和ftell函数。以下是两者的定义：</p>
<blockquote>
<p><code>int fseek(FILE *stream, long offset, int fromwhere);</code><br>函数设置文件指针stream的位置。如果执行成功，stream将指向以fromwhere（偏移起始位置：文件头0(SEEK_SET)，当前位置1(SEEK_CUR)，文件尾2(SEEK_END)）为基准，偏移offset（指针偏移量）个字节的位置。如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置。<br><code>long ftell(FILE *stream);</code><br>函数 ftell 用于得到文件位置指针当前位置相对于文件首的偏移字节数。</p>
</blockquote>
<p>其中fseek的offset还有ftell的返回值都是long型，根据long型的取值范围 $-2^{31}$~$2^{31}-1$ （-2147483648～2147483647），故对大于2.1G的文件进行操作时出错。<br>下面是一段引述自<a href="https://en.wikipedia.org/wiki/Large_file_support" target="_blank" rel="external">维基百科</a>的解释：</p>
<blockquote>
<p>Many old interfaces, especially C-based ones, explicitly specified argument types in a way that did not allow straightforward or transparent transition to 64-bit types. For example, the C functions fseek and ftell operate on file positions of type long int, which is typically 32 bits wide on 32-bit platforms, and cannot be made larger without sacrificing backward compatibility. (This was resolved by introducing new functions fseeko and ftello in POSIX. On Windows machines, under Visual C++, functions _fseeki64 and _ftelli64 are used.)</p>
</blockquote>
<p>大概意思是说对于大文件的支持，处理文件操作时，windows平台上需要用<code>fopen</code>，<code>_ftelli64</code>和<code>_fseeki64</code>，linux平台则用<code>fopen64</code>，<code>ftello64</code>和<code>fseeko64</code>。<br>于是在代码中增加如下定义：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#if</span> <span class="selector-tag">defined</span>(WIN32) || <span class="selector-tag">defined</span>(WIN64)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FOPEN_FUNC</span>(filename, mode) <span class="selector-tag">fopen</span>(filename, mode)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FTELL_FUNC</span>(stream) <span class="selector-tag">_ftelli64</span>(stream)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FSEEK_FUNC</span>(stream, offset, origin) <span class="selector-tag">_fseeki64</span>(stream, offset, origin)</div><div class="line"><span class="selector-id">#else</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FOPEN_FUNC</span>(filename, mode) <span class="selector-tag">fopen64</span>(filename, mode)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FTELL_FUNC</span>(stream) <span class="selector-tag">ftello64</span>(stream)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FSEEK_FUNC</span>(stream, offset, origin) <span class="selector-tag">fseeko64</span>(stream, offset, origin)</div><div class="line"><span class="selector-id">#endif</span></div></pre></td></tr></table></figure></p>
<p>同时将原来的<code>fopen</code>，<code>fseek</code>和<code>ftell</code>函数调用换为<code>FOPEN_FUNC</code>，<code>FSEEK_FUNC</code>，<code>FTELL_FUNC</code>。顺利通过第二关。</p>
<h2 id="Round-3"><a href="#Round-3" class="headerlink" title="Round 3"></a><strong>Round 3</strong></h2><h3 id="解压文件失败"><a href="#解压文件失败" class="headerlink" title="解压文件失败"></a>解压文件失败</h3><p>项目中解压用到了第三方的解压缩库zlib。网上有人说zlib就是不支持大文件的解压，-_-!，不会这么坑吧。如果真是这样，那还得换一个支持大文件解压缩的库（PS此刻想死的心都有）。<br>后来通过调试发现，问题不是出在zlib库的内部，而是出在了调用zlib的函数里面。主要原因如第二关中所说，于是将其中用到的<code>fopen</code>，<code>fseek</code>和<code>ftell</code>函数调用换为<code>FOPEN_FUNC</code>，<code>FSEEK_FUNC</code>，<code>FTELL_FUNC</code>。重新编译运行，问题解决了。所以说，网上的有些说法是不靠谱的。zlib库是支持大文件解压缩的。<br>至此，windows平台下大文件下载的问题算是解决了。</p>
<h2 id="Round-4"><a href="#Round-4" class="headerlink" title="Round 4"></a><strong>Round 4</strong></h2><h3 id="linux平台不work"><a href="#linux平台不work" class="headerlink" title="linux平台不work"></a>linux平台不work</h3><p>既然windows平台已经可以支持大文件的下载了，下面只要测试一下linux平台就OK了。然而事情并没有想象的那么简单，用改过的代码编译之后（庆幸没有遇到问题），跑了一个下载流程。意外发生了：程序跑到一半的时候出错，<code>File size limit exceeded</code>。做了一番google之后，发现原来对于linux平台下大文件的支持需要注意以下事项：</p>
<blockquote>
<ol>
<li><p>在所需要的头文件的#include之前添加如下几行代码：<br><code>#ifndef __USE_FILE_OFFSET64</code><br><code>#define __USE_FILE_OFFSET64</code><br><code>#endif</code><br><code>#ifndef __USE_LARGEFILE64</code><br><code>#define __USE_LARGEFILE64</code><br><code>#endif</code><br><code>#ifndef _LARGEFILE64_SOURCE</code><br><code>#define _LARGEFILE64_SOURCE</code><br><code>#endif</code></p>
</li>
<li><p>在编译程序的时候，加入如下选项：<br><code>-D_FILE_OFFSET_BITS=64 -D_LARGE_FILE</code></p>
</li>
<li><p>在程序的函数中，要注意如下几个方面：</p>
</li>
</ol>
<ul>
<li>首先32位机器用<code>fopen/fclose</code>打开大文件没有问题，顺序读写操作<code>while(!feof(fp)){ fread / fgets / fscanf }或while(1){ fwrite / fputs / fprintf}</code> 也没有问题。</li>
<li>由于32位机器下long是32位，故  <figure class="highlight plain"><figcaption><span>(FILE *stream, off_t offset, int whence)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">off_t ftello(FILE *stream)</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>不能访问4G以上文件。此时要用<br>     <figure class="highlight plain"><figcaption><span>(FILE *stream, off_t offset, int whence)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">off_t ftello(FILE *stream)</div></pre></td></tr></table></figure></p>
<p>依葫芦画瓢，按照以上步骤改过之后再编译测试就通过了。</p>
<p>OK, 经过以上的努力总算是通关了。整个过程一步一步摸索得来，为了让和我遇到类似问题的广大猿友们少走些弯路，故作此文。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近项目中遇到了下载大文件（大于2G）失败的问题。查看了代码之后发现从一开始实现的时候就没有考虑对大文件的支持&lt;i class=&quot;fa fa
    
    </summary>
    
    
      <category term="2G, Big File Size, 大文件" scheme="http://yoursite.com/tags/2G-Big-File-Size-%E5%A4%A7%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>EdgeCast FTP Upload文件size变小问题的解决</title>
    <link href="http://yoursite.com/2016/08/17/EdgeCast%20FTP%20Upload%E6%96%87%E4%BB%B6size%E5%8F%98%E5%B0%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2016/08/17/EdgeCast FTP Upload文件size变小问题的解决/</id>
    <published>2016-08-17T05:49:03.038Z</published>
    <updated>2016-08-17T09:40:24.718Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做EdgeCast CDN的评估，包括file的upload以及purge功能。因为之前有已经实现的ftp的组件，并且在实际生产中用于Akamai CDN的文件上传，未出现什么问题。然而，应用这个组件上传文件到edgecast的ftp上时发现文件竟然变小了！<br><a id="more"></a><br>起初我怀疑是edgecast ftp的问题，于是我就试着用现有的ftp软件8uftp去上传，发现不存在文件变小的问题。那么可能是我们代码的问题，可是奇怪的是为什么对于akamai的ftp就没有问题呢。此时我想到了用wireshark来捕捉ftp网络数据。<br><img src="/img/capture1.png" alt="有问题的抓包"><br>图中上面部分的是akamai的ftp传输过程，下面部分是edgecast的ftp传输过程。仔细比较可发现，akamai ftp对于STOR命令的response是“150 Opening BINARY mode data connection for xxx.7z”，而edgecast ftp对于STOR命令的response是”150 Accepted data connection”。所以akamai ftp默认的传输模式就是binary，而edgecast ftp的默认传输模式是ascii。于是在代码里STOR之前指定传输模式为binary，问题就解决了。附上修改之后的网络数据包。<br><img src="/img/capture2.png" alt="修改过后没问题的抓包"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做EdgeCast CDN的评估，包括file的upload以及purge功能。因为之前有已经实现的ftp的组件，并且在实际生产中用于Akamai CDN的文件上传，未出现什么问题。然而，应用这个组件上传文件到edgecast的ftp上时发现文件竟然变小了！&lt;br&gt;
    
    </summary>
    
    
      <category term="EdgeCast, FTP" scheme="http://yoursite.com/tags/EdgeCast-FTP/"/>
    
  </entry>
  
  <entry>
    <title>Akamai CCU V3 Fast Purge</title>
    <link href="http://yoursite.com/2016/08/17/Akamai%20CCU%20V3%20Fast%20Purge/"/>
    <id>http://yoursite.com/2016/08/17/Akamai CCU V3 Fast Purge/</id>
    <published>2016-08-17T02:19:34.004Z</published>
    <updated>2016-08-17T09:40:17.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p>Akamai是著名的CDN内容提供商。它提供了一套purge的API用于清空Edge Server上的缓存，使客户可以拿到最新的内容。目前在用的是CCU OPEN V2 API，主要是基于XML或JASON的一套REST API。通过调用它，会将相应的purge请求加入一个队列中，同时它也提供了query status的API用于查询purge请求的状态。一般情况下，从提交请求到请求执行完成需要4-7min。<br>这里想要介绍的是Akamai那边提供的V3版本的API，目前处于Beta阶段。最大的卖点就是Fast Purge - Featuring 5-second purge。<br><a id="more"></a></p>
<ul>
<li>Purge utility is Fast Purge, if enabled on the account (estimated time is approximately five seconds). If Fast Purge is not properly enabled on the account, the purge is processed using the legacy (v2) CCU version (estimated time is approximately 4–7 minutes).*</li>
<li>Purges are processed instantaneously - there is no longer a notion of a queue, neither “default” nor “emergency”.*</li>
<li>You can add objects to a total of 50K per request.*</li>
<li>You can choose to “invalidate” or “delete”.*</li>
<li>“production” and “staging” can be purged as separate commands.  This is detailed further down in this post.*</li>
<li>The V3 code will work even before the fast purge is turned on for your properties, so you can implement the code and turn on the functionality as soon as it’s ready.  These calls will be redirected to the V2 OPEN API on the back end.*</li>
</ul>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="Authorize-client"><a href="#Authorize-client" class="headerlink" title="Authorize client"></a>Authorize client</h3><p>OPEN API clients interact with the Akamai Intelligent Platform™ by signing each API request with credentials that are created specifically for each OPEN API client. The scope of the authorization is managed by you. These credentials are analogous to other types of system private data, such as ssh keys, and should be treated with the same care.<br>The authorization to call an API is managed in the Akamai Luna Control Center; however, not every Luna Control Center user will have permissions to create API authorizations. In order to manage API credentials, a user must have the Admin role in the context (account level or group level) the credentials will be tied to. Different organizations choose to grant this privilege to different classes of users. If you don’t see the Manage APIs menu item in the instructions below, then you may not have permission to manage API authorizations. If you find this to be the case, please consult your local administrator. They can either create the authorization you will need for this exercise, or they may grant you the permission to create API authorizations as appropriate to your organization.<br><strong>steps</strong></p>
<ol>
<li>Create an API client</li>
<li>Grant that client permission to call the API we are working with</li>
<li>Save our work to the Akamai Intelligent Platform</li>
<li>Download the authentication tokens so the local API client can use them to sign the API requests (client-api-kickstart.txt: contains Base URL, Access Tokens, Client token, and Secret)</li>
</ol>
<hr>
<h3 id="CCU-request"><a href="#CCU-request" class="headerlink" title="CCU request"></a>CCU request</h3><p>Purge methods (Invalidate or Delete by URL) currently available with this API by task type, as well as an estimated completion time, are as follows:</p>
<table>
<thead>
<tr>
<th style="text-align:left"><em>Action</em></th>
<th style="text-align:left"><em>Operation</em></th>
<th style="text-align:left"><em>API EndPoint</em></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Invalidate by URL</td>
<td style="text-align:left">POST</td>
<td style="text-align:left">/ccu/v3/invalidate/url/{network}</td>
</tr>
<tr>
<td style="text-align:left">Delete by URL</td>
<td style="text-align:left">POST</td>
<td style="text-align:left">/ccu/v3/delete/url/{network}</td>
</tr>
</tbody>
</table>
<p><strong>Invalidate by URL</strong><br>Request:<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST  <span class="meta-keyword">/ccu/</span>v3<span class="meta-keyword">/invalidate/</span>url/production</div><div class="line">Content-Type: application/<span class="class">json</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"objects"</span>: [</div><div class="line">        <span class="string">"http://www.example.com/graphics/picture.gif"</span>,</div><div class="line">        <span class="string">"http://www.site-example.com/graphics/picture.gif"</span>,</div><div class="line">        <span class="string">"http://www.example1.com/documents/brochure.pdf"</span> </div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Response：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"httpStatus"</span>: <span class="number">201</span>,</div><div class="line">    <span class="attr">"detail"</span>: <span class="string">"Request accepted."</span>,</div><div class="line">    <span class="attr">"estimatedSeconds"</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">"purgeId"</span>: <span class="string">"043f-4af0-843f-aaf0043faaf0"</span>,</div><div class="line">    <span class="attr">"supportId"</span>: <span class="string">"17PY1321286429616716-211907680"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Delete by URL</strong><br>Request:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST  /ccu/v3/<span class="keyword">delete</span>/<span class="keyword">url</span>/production</div><div class="line"><span class="keyword">Content</span>-<span class="keyword">Type</span>: application/<span class="keyword">json</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"objects"</span>: [</div><div class="line">        <span class="string">"http://www.example.com/graphics/picture.gif"</span>,</div><div class="line">        <span class="string">"http://www.site-example.com/graphics/picture.gif"</span>,</div><div class="line">        <span class="string">"http://www.example1.com/documents/brochure.pdf"</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Response:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"httpStatus"</span>: <span class="number">201</span>,</div><div class="line">    <span class="attr">"detail"</span>: <span class="string">"Request accepted."</span>,</div><div class="line">    <span class="attr">"estimatedSeconds"</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">"purgeId"</span>: <span class="string">"043f-4af0-843f-aaf0043faaf0"</span>,</div><div class="line">    <span class="attr">"supportId"</span>: <span class="string">"17PY1321286429616716-211907680"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="Signing-API-request"><a href="#Signing-API-request" class="headerlink" title="Signing API request"></a>Signing API request</h3><p>The signature is the base64-encoding of the SHA–256 HMAC of the data to sign with the signing key.<br>You can get an <a href="https://github.com/akamai-open" target="_blank" rel="external">EdgeGrid Request Signature Module</a>.</p>
<h4 id="Signing-Key"><a href="#Signing-Key" class="headerlink" title="Signing Key"></a>Signing Key</h4><p>The signing key is derived from the client secret. The signing key is computed as the base64 encoding of the SHA–256 HMAC of the timestamp string (the field value included in the HTTP authorization header described above) with the client secret as the key.<br><img src="/img/CCU_V3_WorkFlow.jpg" alt="Akamai CCU V3 WorkFlow"></p>
<h4 id="Example-Data-to-Sign"><a href="#Example-Data-to-Sign" class="headerlink" title="Example Data to Sign"></a>Example Data to Sign</h4><p>Raw CCU v3 request:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/diagnostic-tools/<span class="built_in">v1</span>/locations</div></pre></td></tr></table></figure></p>
<p>the data to sign looks like this (\t represents a tab, line breaks added for readability):<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET<span class="symbol">\t</span>https<span class="symbol">\t</span>akaa-xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx.luna.akamaiapis.net<span class="symbol">\t</span></div><div class="line">/diagnostic-tools/v1/locations<span class="symbol">\t</span><span class="symbol">\t</span><span class="symbol">\t</span>EG1-HMAC-SHA256</div><div class="line">client_token=akab-xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx;</div><div class="line">access_token=akab-xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx;</div><div class="line">timestamp=20140402T18:05:06+0000;</div><div class="line">nonce=185f94eb-537c-4c01-b8cc-2fa5a06aee7f;</div></pre></td></tr></table></figure></p>
<h3 id="More-information"><a href="#More-information" class="headerlink" title="More information"></a>More information</h3><p><a href="https://developer.akamai.com/api/purge/ccu/overview.html" target="_blank" rel="external">https://developer.akamai.com/api/purge/ccu/overview.html</a><br><a href="https://developer.akamai.com/introduction/Client_Auth.html" target="_blank" rel="external">https://developer.akamai.com/introduction/Client_Auth.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Concept&quot;&gt;&lt;a href=&quot;#Concept&quot; class=&quot;headerlink&quot; title=&quot;Concept&quot;&gt;&lt;/a&gt;Concept&lt;/h2&gt;&lt;p&gt;Akamai是著名的CDN内容提供商。它提供了一套purge的API用于清空Edge Server上的缓存，使客户可以拿到最新的内容。目前在用的是CCU OPEN V2 API，主要是基于XML或JASON的一套REST API。通过调用它，会将相应的purge请求加入一个队列中，同时它也提供了query status的API用于查询purge请求的状态。一般情况下，从提交请求到请求执行完成需要4-7min。&lt;br&gt;这里想要介绍的是Akamai那边提供的V3版本的API，目前处于Beta阶段。最大的卖点就是Fast Purge - Featuring 5-second purge。&lt;br&gt;
    
    </summary>
    
    
      <category term="Akamai,Fast Purge" scheme="http://yoursite.com/tags/Akamai-Fast-Purge/"/>
    
  </entry>
  
</feed>
