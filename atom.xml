<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>红尘漫步</title>
  <subtitle>爱吃鱼的小强</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-30T03:27:07.665Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Justin Zhou</name>
    <email>13912926126@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二进制差量更新算法比较</title>
    <link href="http://yoursite.com/2016/08/30/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B7%AE%E9%87%8F%E6%9B%B4%E6%96%B0%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2016/08/30/二进制差量更新算法比较/</id>
    <published>2016-08-30T03:23:35.631Z</published>
    <updated>2016-08-30T03:27:07.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>本文对目前比较流行的基于二进制差量更新算法的几个实现进行了一个比较。<br>差量更新算法的核心思想是尽可能多的利用old文件中已有的内容，尽可能少的加入新的内容来构建new文件。通常的做法是对old文件和new文件做子字符串匹配或使用hash技术，提取公共部分，将new文件中剩余的部分打包成patch包，在Patch阶段中，用copying和insertion两个基本操作即可将old文件和patch包合成new文件。<br><a id="more"></a><br><img src="/img/patching_diagram.jpg" alt="差量更新示意图">比较时主要基于以下标准：<br><img src="/img/compare_standard.jpg" alt="比较标准"></p>
<h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p><img src="/img/diff_approach.jpg" alt="diff approach"></p>
<h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>Rdiff：做出的diff太大。<br>Bsdiff：它需要max(17<em>n,9</em>n+m)+O(1) bytes的内存，n是old文件的size，m是新文件的size。换句话说，它不能处理特别大的文件。<br>Courgetee：google的项目，初衷是减少Chrome的网络流量。基于bsdiff针对可执行文件类型做了些优化，所以它也不能处理太大的文件。<br>OpenVcdiff：它用了delta encoding算法(RFC3284)。它的实现是将old文件全部加载到内存中处理，所以它也不能处理太大文件。<br>zdelta：不支持windows平台，并且处理大文件时性能比较低。<br>xdelta3：采用delta encoding算法，支持特大文件，性能好并且平台独立。但是它遵循GPL v2 license，对商业应用不友好。<br>Rtpatch Server：rtpatch的增强版，提供了windows平台的多线程build功能。属于一款应用较广泛的商业软件。<br><img src="/img/compare_metrix.jpg" alt="比较矩阵"><br>接着从build diff的size和CPU以及内存消耗方面比较了一下rtpatchserver和xdelta3。<br><img src="/img/P.4.png" alt="build diff size compare"><br><img src="/img/compare_performance.jpg" alt="performance compare"></p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>通过比较可以发现，若是商业应用的话满足所有标准的只有RtpatchServer。若是内部使用的话则xdelta3的表现明显好于其他。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;本文对目前比较流行的基于二进制差量更新算法的几个实现进行了一个比较。&lt;br&gt;差量更新算法的核心思想是尽可能多的利用old文件中已有的内容，尽可能少的加入新的内容来构建new文件。通常的做法是对old文件和new文件做子字符串匹配或使用hash技术，提取公共部分，将new文件中剩余的部分打包成patch包，在Patch阶段中，用copying和insertion两个基本操作即可将old文件和patch包合成new文件。&lt;br&gt;
    
    </summary>
    
    
      <category term="Delta Encoding, 差量更新, VCDiff, Rtpatch" scheme="http://yoursite.com/tags/Delta-Encoding-%E5%B7%AE%E9%87%8F%E6%9B%B4%E6%96%B0-VCDiff-Rtpatch/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL与fPIC</title>
    <link href="http://yoursite.com/2016/08/26/OpenSSL%E4%B8%8EfPIC/"/>
    <id>http://yoursite.com/2016/08/26/OpenSSL与fPIC/</id>
    <published>2016-08-26T09:49:01.305Z</published>
    <updated>2016-08-30T03:27:25.425Z</updated>
    
    <content type="html"><![CDATA[<p>看到标题大家可能会想，openssl和fPIC会有什么关系呢？这要从最近遇到的一个问题说起。由于openssl去年和今年被爆出了很多漏洞，而我们项目中用到了openssl较老的版本，所以需要重新编译openssl的新版本。这本应该是一间很简单的事，可是却遇到了问题。在RedHat 7.x平台上，编译之后的程序在跑的时候直接crash了，而且奇怪的是在RedHat AS4平台上没有问题。<br><a id="more"></a><br>废话不多说，上错误栈:<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Program terminated <span class="keyword">with</span> signal <span class="number">11</span>, Segmentation fault.</div><div class="line"><span class="string">#0</span> <span class="number">0</span>xf7779875c <span class="keyword">in</span> sha1_block_data_order () <span class="keyword">from</span> /opt/xxx/xxx/libxxx.so</div><div class="line"><span class="string">#1</span> <span class="number">0</span>xf7797926 <span class="keyword">in</span> SHA1_Update () <span class="keyword">from</span> /opt/xxx/xxx/libxxx.so</div><div class="line"><span class="string">#2</span> <span class="number">0</span>x00000000 <span class="keyword">in</span> ?? ()</div></pre></td></tr></table></figure></p>
<p>以<code>sha1_block_data_order</code>为关键字经过一番搜索，发现网上也有遇到类似crash问题的人。给出的解释是，因为多线程调用，openssl在多线程调用时为了保证线程安全，需要在每个调用线程里明确设置两个callback函数。引用如下：</p>
<blockquote>
<p>Is OpenSSL thread-safe?<br>Yes (with limitations: an SSL connection may not concurrently be used by multiple threads). On Windows and many Unix systems, OpenSSL automatically uses the multi-threaded versions of the standard libraries. If your platform is not one of these, consult the INSTALL file.</p>
<p>Multi-threaded applications must provide two callback functions to OpenSSL by calling CRYPTO_set_locking_callback() and CRYPTO_set_id_callback(), for all versions of OpenSSL up to and including 0.9.8[abc…]. As of version 1.0.0, CRYPTO_set_id_callback() and associated APIs are deprecated by CRYPTO_THREADID_set_callback() and friends. This is described in the threads(3) manpage.</p>
</blockquote>
<p>本以为找着了问题的原因，然而在仔细搜索了代码之后发现我们已经设置了这两个callback。然后自己在redhat 7.3上面写了一个demo程序去调用，单线程的竟然也会crash！不过还好，本地可以复现。重新编译了一个debug版本的程序，用gdb一步一步的去跟。最后获取了比较详细的调用栈：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">sha1_block_data_order ()</div><div class="line">#<span class="number">0</span>  SHA1_Update (c=<span class="number">0x80d7f60</span>, data_=<span class="number">0xbfff5fe0</span>, len=<span class="number">8</span>) <span class="meta">at</span> ../md32_common.h:<span class="number">307</span></div><div class="line">#<span class="number">1</span>  <span class="number">0x40350e27</span> <span class="keyword">in</span> update (ctx=<span class="number">0xbfff5fa0</span>, data=<span class="number">0xbfff5fe0</span>, count=<span class="number">8</span>) <span class="meta">at</span> m_sha1.c:<span class="number">80</span></div><div class="line">#<span class="number">2</span>  <span class="number">0x4034879a</span> <span class="keyword">in</span> EVP_DigestUpdate (ctx=<span class="number">0xbfff5fa0</span>, data=<span class="number">0xbfff5fe0</span>, count=<span class="number">8</span>)</div><div class="line">    <span class="meta">at</span> digest.c:<span class="number">244</span></div><div class="line">#<span class="number">3</span>  <span class="number">0x403e1bb3</span> <span class="keyword">in</span> ssleay_rand_add (buf=<span class="number">0xbfff61c0</span>, num=<span class="number">32</span>, <span class="keyword">add</span>=<span class="number">32</span>) <span class="meta">at</span> md_rand.c:<span class="number">288</span></div><div class="line">#<span class="number">4</span>  <span class="number">0x40345cdc</span> <span class="keyword">in</span> RAND_add (buf=<span class="number">0xbfff61c0</span>, num=<span class="number">32</span>, entropy=<span class="number">32</span>) <span class="meta">at</span> rand_lib.c:<span class="number">152</span></div><div class="line">#<span class="number">5</span>  <span class="number">0x403e298b</span> <span class="keyword">in</span> RAND_poll () <span class="meta">at</span> rand_unix.c:<span class="number">405</span></div><div class="line">#<span class="number">6</span>  <span class="number">0x403e24c3</span> <span class="keyword">in</span> ssleay_rand_status () <span class="meta">at</span> md_rand.c:<span class="number">578</span></div><div class="line">#<span class="number">7</span>  <span class="number">0x40345de4</span> <span class="keyword">in</span> RAND_status () <span class="meta">at</span> rand_lib.c:<span class="number">175</span></div><div class="line">#<span class="number">8</span>  <span class="number">0x40294a39</span> <span class="keyword">in</span> _seedPRNG () <span class="meta">at</span> xxx.cpp:<span class="number">65</span></div></pre></td></tr></table></figure></p>
<p>程序出错在程序给openssl发送随机种子时调用的<code>sha1_block_data_order</code>函数里，以下是此函数的定义：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">$A=<span class="string">"eax"</span>;</div><div class="line">$B=<span class="string">"ebx"</span>;</div><div class="line">$C=<span class="string">"ecx"</span>;</div><div class="line">$D=<span class="string">"edx"</span>;</div><div class="line">$E=<span class="string">"edi"</span>;</div><div class="line">$T=<span class="string">"esi"</span>;</div><div class="line">$tmp1=<span class="string">"ebp"</span>;</div><div class="line"></div><div class="line">&amp;function_begin(<span class="string">"sha1_block_data_order"</span>);</div><div class="line">	&amp;mov($tmp1,&amp;wparam(<span class="number">0</span>));	<span class="comment"># SHA_CTX *c</span></div><div class="line">	&amp;mov($T,&amp;wparam(<span class="number">1</span>));	<span class="comment"># const void *input</span></div><div class="line">	&amp;mov($A,&amp;wparam(<span class="number">2</span>));	<span class="comment"># size_t num</span></div><div class="line">	&amp;stack_push(<span class="number">16</span>);	<span class="comment"># allocate X[16]</span></div><div class="line">	&amp;shl($A,<span class="number">6</span>);</div><div class="line">	&amp;add($A,$T);</div><div class="line">	&amp;mov(&amp;wparam(<span class="number">2</span>),$A);	<span class="comment"># pointer beyond the end of input</span></div><div class="line">	&amp;mov($E,&amp;DWP(<span class="number">16</span>,$tmp1));<span class="comment"># pre-load E</span></div><div class="line"></div><div class="line">	&amp;set_label(<span class="string">"loop"</span>,<span class="number">16</span>);</div><div class="line"></div><div class="line">	<span class="comment"># copy input chunk to X, but reversing byte order!</span></div><div class="line">	<span class="keyword">for</span> ($i=<span class="number">0</span>; $i&lt;<span class="number">16</span>; $i+=<span class="number">4</span>)</div><div class="line">		&#123;</div><div class="line">		&amp;mov($A,&amp;DWP(<span class="number">4</span>*($i+<span class="number">0</span>),$T));</div><div class="line">		&amp;mov($B,&amp;DWP(<span class="number">4</span>*($i+<span class="number">1</span>),$T));</div><div class="line">		&amp;mov($C,&amp;DWP(<span class="number">4</span>*($i+<span class="number">2</span>),$T));</div><div class="line">		&amp;mov($D,&amp;DWP(<span class="number">4</span>*($i+<span class="number">3</span>),$T));</div><div class="line">		&amp;bswap($A);</div><div class="line">		&amp;bswap($B);</div><div class="line">		&amp;bswap($C);</div><div class="line">		&amp;bswap($D);</div><div class="line">		&amp;mov(&amp;swtmp($i+<span class="number">0</span>),$A);</div><div class="line">		&amp;mov(&amp;swtmp($i+<span class="number">1</span>),$B);</div><div class="line">		&amp;mov(&amp;swtmp($i+<span class="number">2</span>),$C);</div><div class="line">		&amp;mov(&amp;swtmp($i+<span class="number">3</span>),$D);</div><div class="line">		&#125;</div><div class="line">	&amp;mov(&amp;wparam(<span class="number">1</span>),$T);	<span class="comment"># redundant in 1st spin</span></div><div class="line"></div><div class="line">	&amp;mov($A,&amp;DWP(<span class="number">0</span>,$tmp1));	<span class="comment"># load SHA_CTX</span></div><div class="line">	&amp;mov($B,&amp;DWP(<span class="number">4</span>,$tmp1));</div><div class="line">	&amp;mov($C,&amp;DWP(<span class="number">8</span>,$tmp1));</div><div class="line">	&amp;mov($D,&amp;DWP(<span class="number">12</span>,$tmp1));</div><div class="line">	<span class="comment"># E is pre-loaded</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;<span class="number">16</span>;$i++)	&#123; &amp;BODY_00_15($i,@V); <span class="keyword">unshift</span>(@V,<span class="keyword">pop</span>(@V)); &#125;</div><div class="line">	<span class="keyword">for</span>(;$i&lt;<span class="number">20</span>;$i++)	&#123; &amp;BODY_16_19($i,@V); <span class="keyword">unshift</span>(@V,<span class="keyword">pop</span>(@V)); &#125;</div><div class="line">	<span class="keyword">for</span>(;$i&lt;<span class="number">40</span>;$i++)	&#123; &amp;BODY_20_39($i,@V); <span class="keyword">unshift</span>(@V,<span class="keyword">pop</span>(@V)); &#125;</div><div class="line">	<span class="keyword">for</span>(;$i&lt;<span class="number">60</span>;$i++)	&#123; &amp;BODY_40_59($i,@V); <span class="keyword">unshift</span>(@V,<span class="keyword">pop</span>(@V)); &#125;</div><div class="line">	<span class="keyword">for</span>(;$i&lt;<span class="number">80</span>;$i++)	&#123; &amp;BODY_20_39($i,@V); <span class="keyword">unshift</span>(@V,<span class="keyword">pop</span>(@V)); &#125;</div><div class="line"></div><div class="line">	(($V[<span class="number">5</span>] eq $D) <span class="keyword">and</span> ($V[<span class="number">0</span>] eq $E)) <span class="keyword">or</span> <span class="keyword">die</span>;	<span class="comment"># double-check</span></div><div class="line"></div><div class="line">	&amp;mov($tmp1,&amp;wparam(<span class="number">0</span>));	<span class="comment"># re-load SHA_CTX*</span></div><div class="line">	&amp;mov($D,&amp;wparam(<span class="number">1</span>));	<span class="comment"># D is last "T" and is discarded</span></div><div class="line"></div><div class="line">	&amp;add($E,&amp;DWP(<span class="number">0</span>,$tmp1));	<span class="comment"># E is last "A"...</span></div><div class="line">	&amp;add($T,&amp;DWP(<span class="number">4</span>,$tmp1));</div><div class="line">	&amp;add($A,&amp;DWP(<span class="number">8</span>,$tmp1));</div><div class="line">	&amp;add($B,&amp;DWP(<span class="number">12</span>,$tmp1));</div><div class="line">	&amp;add($C,&amp;DWP(<span class="number">16</span>,$tmp1));</div><div class="line"></div><div class="line">	&amp;mov(&amp;DWP(<span class="number">0</span>,$tmp1),$E);	<span class="comment"># update SHA_CTX</span></div><div class="line">	 &amp;add($D,<span class="number">64</span>);		<span class="comment"># advance input pointer</span></div><div class="line">	&amp;mov(&amp;DWP(<span class="number">4</span>,$tmp1),$T);</div><div class="line">	 &amp;cmp($D,&amp;wparam(<span class="number">2</span>));	<span class="comment"># have we reached the end yet?</span></div><div class="line">	&amp;mov(&amp;DWP(<span class="number">8</span>,$tmp1),$A);</div><div class="line">	 &amp;mov($E,$C);		<span class="comment"># C is last "E" which needs to be "pre-loaded"</span></div><div class="line">	&amp;mov(&amp;DWP(<span class="number">12</span>,$tmp1),$B);</div><div class="line">	 &amp;mov($T,$D);		<span class="comment"># input pointer</span></div><div class="line">	&amp;mov(&amp;DWP(<span class="number">16</span>,$tmp1),$C);</div><div class="line">	&amp;jb(&amp;label(<span class="string">"loop"</span>));</div><div class="line"></div><div class="line">	&amp;stack_pop(<span class="number">16</span>);</div><div class="line">&amp;function_end(<span class="string">"sha1_block_data_order"</span>);</div></pre></td></tr></table></figure></p>
<p>可以发现其中用到了大量的寄存器，eax/ebx/ecx/edx等。后来突然联想到在编译openssl的时候我们加上了-fPIC选项，fPIC作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)，则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。那么会不会是-fPIC选项对于内嵌汇编代码的支持不好造成的呢。于是重新编译了一下openssl的库，问题果然解决了。<br>在问题解决之后又做了一些research，找到了一篇文章“<a href="http://blog.itpub.net/67063/viewspace-169190/" target="_blank" rel="external">gcc指定-fPIC编译的时候内嵌汇编需要注意的问题</a>”。其中有提到：</p>
<blockquote>
<p>gcc在生成位置无关代码的时候，内部使用了ebx作为基址寄存器。如果不使用内嵌汇编，那么gcc自然会帮助你维持ebx的值始终有效。但是如果使用了内嵌汇编，gcc常常就有点力不从心了，所以这时候，一定要自己留意保存好ebx的值。</p>
</blockquote>
<p>所以造成<code>sha1_block_data_order</code> crash的原因应该就是其中用到了ebx，而且没有自己去保存好它。而对于位置无关的代码内部使用了ebx作为基址寄存器，所以就出现了Segmentation fault。可是还有一个问题，为什么redhat AS4平台上也用了fPIC而没有问题呢。我想这应该是因为老版本的编译器对于这种情况的handle不是很好。因为redhat 7.x的gcc版本确实比较低了些。<br>希望我跨过的这个坑会对后来人有所帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到标题大家可能会想，openssl和fPIC会有什么关系呢？这要从最近遇到的一个问题说起。由于openssl去年和今年被爆出了很多漏洞，而我们项目中用到了openssl较老的版本，所以需要重新编译openssl的新版本。这本应该是一间很简单的事，可是却遇到了问题。在RedHat 7.x平台上，编译之后的程序在跑的时候直接crash了，而且奇怪的是在RedHat AS4平台上没有问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="Openssl, fPIC, sha1_block_data_order, crash" scheme="http://yoursite.com/tags/Openssl-fPIC-sha1-block-data-order-crash/"/>
    
  </entry>
  
  <entry>
    <title>下载（2G以上）大文件支持小记</title>
    <link href="http://yoursite.com/2016/08/24/%E4%B8%8B%E8%BD%BD%EF%BC%882G%E4%BB%A5%E4%B8%8A%EF%BC%89%E5%A4%A7%E6%96%87%E4%BB%B6%E6%94%AF%E6%8C%81%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/08/24/下载（2G以上）大文件支持小记/</id>
    <published>2016-08-24T02:30:40.651Z</published>
    <updated>2016-08-30T03:26:47.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近项目中遇到了下载大文件（大于2G）失败的问题。查看了代码之后发现从一开始实现的时候就没有考虑对大文件的支持<i class="fa fa-frown-o"></i>。老板追的紧，没办法只能硬着头皮上。整个的解决过程就好像打怪升级一般，一步一个脚印。<br><a id="more"></a></p>
<h2 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a><strong>Round 1</strong></h2><h3 id="下载文件size每次都是2G"><a href="#下载文件size每次都是2G" class="headerlink" title="下载文件size每次都是2G"></a>下载文件size每次都是2G</h3><p>为什么每次下载的文件都是2G，明明在server端的文件是大于2G的。通过调试发现原来在下载的代码实现中，一些基本变量的定义都是int类型的，也就是说最大只能存储 $2^{31}-1$ 的正整数。所以需要将这些有影响的变量类型改为范围更大的类型。考虑到项目是多平台程序，所以参考了一下ANSI C/C++的基本数据类型：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th style="text-align:center">Size</th>
<th style="text-align:left">数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>无值型void</td>
<td style="text-align:center">0 byte</td>
<td style="text-align:left">无值域</td>
</tr>
<tr>
<td>布尔型bool</td>
<td style="text-align:center">1 byte</td>
<td style="text-align:left">true   false</td>
</tr>
<tr>
<td>有符号短整型short [int] /signed short [int]</td>
<td style="text-align:center">2 byte</td>
<td style="text-align:left">-32768~32767</td>
</tr>
<tr>
<td>无符号短整型unsigned short [int]</td>
<td style="text-align:center">2 byte</td>
<td style="text-align:left">0~65535</td>
</tr>
<tr>
<td>有符号整型int /signed [int]</td>
<td style="text-align:center">4 byte</td>
<td style="text-align:left">-2147483648~2147483647</td>
</tr>
<tr>
<td>无符号整型unsigned [int]</td>
<td style="text-align:center">4 byte</td>
<td style="text-align:left">0~4294967295</td>
</tr>
<tr>
<td>有符号长整型long [int]/signed long [int]</td>
<td style="text-align:center">4 byte</td>
<td style="text-align:left">-2147483648~2147483647</td>
</tr>
<tr>
<td>无符号长整型unsigned long [int]</td>
<td style="text-align:center">4 byte</td>
<td style="text-align:left">0~4294967295</td>
</tr>
<tr>
<td>有符号 long long</td>
<td style="text-align:center">8 byte</td>
<td style="text-align:left">-9223372036854775808~9223372036854775807</td>
</tr>
<tr>
<td>无符号long long</td>
<td style="text-align:center">8 byte</td>
<td style="text-align:left">0~18446744073709552000</td>
</tr>
<tr>
<td>有符号字符型char/signed char</td>
<td style="text-align:center">1 byte</td>
<td style="text-align:left">-128~127</td>
</tr>
<tr>
<td>无符号字符型unsigned char</td>
<td style="text-align:center">1 byte</td>
<td style="text-align:left">0~255</td>
</tr>
<tr>
<td>宽字符型wchar_t (unsigned short.)</td>
<td style="text-align:center">2 byte</td>
<td style="text-align:left">0~65535</td>
</tr>
<tr>
<td>单精度浮点型float</td>
<td style="text-align:center">4 byte</td>
<td style="text-align:left">-3.4E-38~3.4E+38</td>
</tr>
<tr>
<td>双精度浮点型double</td>
<td style="text-align:center">8 byte</td>
<td style="text-align:left">1.7E-308~1.7E+308</td>
</tr>
<tr>
<td>long double</td>
<td style="text-align:center">8 byte</td>
</tr>
</tbody>
</table>
<p>这里我们选用signed long long类型， 它可表示的最大的正整数是 $2^{63}-1$ ，足以应付4G的文件。增加如下定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> sint64_t_defined</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> sint64_t_defined</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">long</span>     Tsint64;<span class="comment">//It's illegal in C90. It's legel in C99. </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>接着把所有有影响的变量类型改为Tsint64。OK，第一关算是勉强通过了。</p>
<h2 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a><strong>Round 2</strong></h2><h3 id="检查文件size失败"><a href="#检查文件size失败" class="headerlink" title="检查文件size失败"></a>检查文件size失败</h3><p>通过前面的努力，终于可以将大于2G的文件下下来了。可是好景不长，程序走到检查文件size的时候fail了。手工检查了下文件的size是没有问题的，但是程序中获取的size是一个很奇怪的数。其中获取size的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">filelen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (fname == <span class="literal">NULL</span> || fname[<span class="number">0</span>] == <span class="string">'\0'</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	FILE *fp = fopen (fname, <span class="string">"rb"</span>);</div><div class="line">	<span class="keyword">if</span> (!fp)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	fseek (fp, <span class="number">0</span>, SEEK_END);</div><div class="line">	<span class="keyword">long</span> length = ftell (fp);</div><div class="line">	fclose (fp);</div><div class="line">	<span class="keyword">return</span> length == <span class="number">-1</span> ? <span class="number">0</span> : (<span class="keyword">unsigned</span> <span class="keyword">int</span>)length;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过调试发现问题出现在fseek和ftell函数。以下是两者的定义：</p>
<blockquote>
<p><code>int fseek(FILE *stream, long offset, int fromwhere);</code><br>函数设置文件指针stream的位置。如果执行成功，stream将指向以fromwhere（偏移起始位置：文件头0(SEEK_SET)，当前位置1(SEEK_CUR)，文件尾2(SEEK_END)）为基准，偏移offset（指针偏移量）个字节的位置。如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置。<br><code>long ftell(FILE *stream);</code><br>函数 ftell 用于得到文件位置指针当前位置相对于文件首的偏移字节数。</p>
</blockquote>
<p>其中fseek的offset还有ftell的返回值都是long型，根据long型的取值范围 $-2^{31}$~$2^{31}-1$ （-2147483648～2147483647），故对大于2.1G的文件进行操作时出错。<br>下面是一段引述自<a href="https://en.wikipedia.org/wiki/Large_file_support" target="_blank" rel="external">维基百科</a>的解释：</p>
<blockquote>
<p>Many old interfaces, especially C-based ones, explicitly specified argument types in a way that did not allow straightforward or transparent transition to 64-bit types. For example, the C functions fseek and ftell operate on file positions of type long int, which is typically 32 bits wide on 32-bit platforms, and cannot be made larger without sacrificing backward compatibility. (This was resolved by introducing new functions fseeko and ftello in POSIX. On Windows machines, under Visual C++, functions _fseeki64 and _ftelli64 are used.)</p>
</blockquote>
<p>大概意思是说对于大文件的支持，处理文件操作时，windows平台上需要用<code>fopen</code>，<code>_ftelli64</code>和<code>_fseeki64</code>，linux平台则用<code>fopen64</code>，<code>ftello64</code>和<code>fseeko64</code>。<br>于是在代码中增加如下定义：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#if</span> <span class="selector-tag">defined</span>(WIN32) || <span class="selector-tag">defined</span>(WIN64)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FOPEN_FUNC</span>(filename, mode) <span class="selector-tag">fopen</span>(filename, mode)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FTELL_FUNC</span>(stream) <span class="selector-tag">_ftelli64</span>(stream)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FSEEK_FUNC</span>(stream, offset, origin) <span class="selector-tag">_fseeki64</span>(stream, offset, origin)</div><div class="line"><span class="selector-id">#else</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FOPEN_FUNC</span>(filename, mode) <span class="selector-tag">fopen64</span>(filename, mode)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FTELL_FUNC</span>(stream) <span class="selector-tag">ftello64</span>(stream)</div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">FSEEK_FUNC</span>(stream, offset, origin) <span class="selector-tag">fseeko64</span>(stream, offset, origin)</div><div class="line"><span class="selector-id">#endif</span></div></pre></td></tr></table></figure></p>
<p>同时将原来的<code>fopen</code>，<code>fseek</code>和<code>ftell</code>函数调用换为<code>FOPEN_FUNC</code>，<code>FSEEK_FUNC</code>，<code>FTELL_FUNC</code>。顺利通过第二关。</p>
<h2 id="Round-3"><a href="#Round-3" class="headerlink" title="Round 3"></a><strong>Round 3</strong></h2><h3 id="解压文件失败"><a href="#解压文件失败" class="headerlink" title="解压文件失败"></a>解压文件失败</h3><p>项目中解压用到了第三方的解压缩库zlib。网上有人说zlib就是不支持大文件的解压，-_-!，不会这么坑吧。如果真是这样，那还得换一个支持大文件解压缩的库（PS此刻想死的心都有）。<br>后来通过调试发现，问题不是出在zlib库的内部，而是出在了调用zlib的函数里面。主要原因如第二关中所说，于是将其中用到的<code>fopen</code>，<code>fseek</code>和<code>ftell</code>函数调用换为<code>FOPEN_FUNC</code>，<code>FSEEK_FUNC</code>，<code>FTELL_FUNC</code>。重新编译运行，问题解决了。所以说，网上的有些说法是不靠谱的。zlib库是支持大文件解压缩的。<br>至此，windows平台下大文件下载的问题算是解决了。</p>
<h2 id="Round-4"><a href="#Round-4" class="headerlink" title="Round 4"></a><strong>Round 4</strong></h2><h3 id="linux平台不work"><a href="#linux平台不work" class="headerlink" title="linux平台不work"></a>linux平台不work</h3><p>既然windows平台已经可以支持大文件的下载了，下面只要测试一下linux平台就OK了。然而事情并没有想象的那么简单，用改过的代码编译之后（庆幸没有遇到问题），跑了一个下载流程。意外发生了：程序跑到一半的时候出错，<code>File size limit exceeded</code>。做了一番google之后，发现原来对于linux平台下大文件的支持需要注意以下事项：</p>
<blockquote>
<ol>
<li><p>在所需要的头文件的#include之前添加如下几行代码：<br><code>#ifndef __USE_FILE_OFFSET64</code><br><code>#define __USE_FILE_OFFSET64</code><br><code>#endif</code><br><code>#ifndef __USE_LARGEFILE64</code><br><code>#define __USE_LARGEFILE64</code><br><code>#endif</code><br><code>#ifndef _LARGEFILE64_SOURCE</code><br><code>#define _LARGEFILE64_SOURCE</code><br><code>#endif</code></p>
</li>
<li><p>在编译程序的时候，加入如下选项：<br><code>-D_FILE_OFFSET_BITS=64 -D_LARGE_FILE</code></p>
</li>
<li><p>在程序的函数中，要注意如下几个方面：</p>
</li>
</ol>
<ul>
<li>首先32位机器用<code>fopen/fclose</code>打开大文件没有问题，顺序读写操作<code>while(!feof(fp)){ fread / fgets / fscanf }或while(1){ fwrite / fputs / fprintf}</code> 也没有问题。</li>
<li>由于32位机器下long是32位，故  <figure class="highlight plain"><figcaption><span>(FILE *stream, off_t offset, int whence)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">off_t ftello(FILE *stream)</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>不能访问4G以上文件。此时要用<br>     <figure class="highlight plain"><figcaption><span>(FILE *stream, off_t offset, int whence)</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">off_t ftello(FILE *stream)</div></pre></td></tr></table></figure></p>
<p>依葫芦画瓢，按照以上步骤改过之后再编译测试就通过了。</p>
<p>OK, 经过以上的努力总算是通关了。整个过程一步一步摸索得来，为了让和我遇到类似问题的广大猿友们少走些弯路，故作此文。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近项目中遇到了下载大文件（大于2G）失败的问题。查看了代码之后发现从一开始实现的时候就没有考虑对大文件的支持&lt;i class=&quot;fa fa-frown-o&quot;&gt;&lt;/i&gt;。老板追的紧，没办法只能硬着头皮上。整个的解决过程就好像打怪升级一般，一步一个脚印。&lt;br&gt;
    
    </summary>
    
    
      <category term="2G, Big File Size, 大文件" scheme="http://yoursite.com/tags/2G-Big-File-Size-%E5%A4%A7%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>EdgeCast FTP Upload文件size变小问题的解决</title>
    <link href="http://yoursite.com/2016/08/17/EdgeCast%20FTP%20Upload%E6%96%87%E4%BB%B6size%E5%8F%98%E5%B0%8F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2016/08/17/EdgeCast FTP Upload文件size变小问题的解决/</id>
    <published>2016-08-17T05:49:03.038Z</published>
    <updated>2016-08-17T09:40:24.718Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做EdgeCast CDN的评估，包括file的upload以及purge功能。因为之前有已经实现的ftp的组件，并且在实际生产中用于Akamai CDN的文件上传，未出现什么问题。然而，应用这个组件上传文件到edgecast的ftp上时发现文件竟然变小了！<br><a id="more"></a><br>起初我怀疑是edgecast ftp的问题，于是我就试着用现有的ftp软件8uftp去上传，发现不存在文件变小的问题。那么可能是我们代码的问题，可是奇怪的是为什么对于akamai的ftp就没有问题呢。此时我想到了用wireshark来捕捉ftp网络数据。<br><img src="/img/capture1.png" alt="有问题的抓包"><br>图中上面部分的是akamai的ftp传输过程，下面部分是edgecast的ftp传输过程。仔细比较可发现，akamai ftp对于STOR命令的response是“150 Opening BINARY mode data connection for xxx.7z”，而edgecast ftp对于STOR命令的response是”150 Accepted data connection”。所以akamai ftp默认的传输模式就是binary，而edgecast ftp的默认传输模式是ascii。于是在代码里STOR之前指定传输模式为binary，问题就解决了。附上修改之后的网络数据包。<br><img src="/img/capture2.png" alt="修改过后没问题的抓包"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做EdgeCast CDN的评估，包括file的upload以及purge功能。因为之前有已经实现的ftp的组件，并且在实际生产中用于Akamai CDN的文件上传，未出现什么问题。然而，应用这个组件上传文件到edgecast的ftp上时发现文件竟然变小了！&lt;br&gt;
    
    </summary>
    
    
      <category term="EdgeCast, FTP" scheme="http://yoursite.com/tags/EdgeCast-FTP/"/>
    
  </entry>
  
  <entry>
    <title>Akamai CCU V3 Fast Purge</title>
    <link href="http://yoursite.com/2016/08/17/Akamai%20CCU%20V3%20Fast%20Purge/"/>
    <id>http://yoursite.com/2016/08/17/Akamai CCU V3 Fast Purge/</id>
    <published>2016-08-17T02:19:34.004Z</published>
    <updated>2016-08-17T09:40:17.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p>Akamai是著名的CDN内容提供商。它提供了一套purge的API用于清空Edge Server上的缓存，使客户可以拿到最新的内容。目前在用的是CCU OPEN V2 API，主要是基于XML或JASON的一套REST API。通过调用它，会将相应的purge请求加入一个队列中，同时它也提供了query status的API用于查询purge请求的状态。一般情况下，从提交请求到请求执行完成需要4-7min。<br>这里想要介绍的是Akamai那边提供的V3版本的API，目前处于Beta阶段。最大的卖点就是Fast Purge - Featuring 5-second purge。<br><a id="more"></a></p>
<ul>
<li>Purge utility is Fast Purge, if enabled on the account (estimated time is approximately five seconds). If Fast Purge is not properly enabled on the account, the purge is processed using the legacy (v2) CCU version (estimated time is approximately 4–7 minutes).*</li>
<li>Purges are processed instantaneously - there is no longer a notion of a queue, neither “default” nor “emergency”.*</li>
<li>You can add objects to a total of 50K per request.*</li>
<li>You can choose to “invalidate” or “delete”.*</li>
<li>“production” and “staging” can be purged as separate commands.  This is detailed further down in this post.*</li>
<li>The V3 code will work even before the fast purge is turned on for your properties, so you can implement the code and turn on the functionality as soon as it’s ready.  These calls will be redirected to the V2 OPEN API on the back end.*</li>
</ul>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="Authorize-client"><a href="#Authorize-client" class="headerlink" title="Authorize client"></a>Authorize client</h3><p>OPEN API clients interact with the Akamai Intelligent Platform™ by signing each API request with credentials that are created specifically for each OPEN API client. The scope of the authorization is managed by you. These credentials are analogous to other types of system private data, such as ssh keys, and should be treated with the same care.<br>The authorization to call an API is managed in the Akamai Luna Control Center; however, not every Luna Control Center user will have permissions to create API authorizations. In order to manage API credentials, a user must have the Admin role in the context (account level or group level) the credentials will be tied to. Different organizations choose to grant this privilege to different classes of users. If you don’t see the Manage APIs menu item in the instructions below, then you may not have permission to manage API authorizations. If you find this to be the case, please consult your local administrator. They can either create the authorization you will need for this exercise, or they may grant you the permission to create API authorizations as appropriate to your organization.<br><strong>steps</strong></p>
<ol>
<li>Create an API client</li>
<li>Grant that client permission to call the API we are working with</li>
<li>Save our work to the Akamai Intelligent Platform</li>
<li>Download the authentication tokens so the local API client can use them to sign the API requests (client-api-kickstart.txt: contains Base URL, Access Tokens, Client token, and Secret)</li>
</ol>
<hr>
<h3 id="CCU-request"><a href="#CCU-request" class="headerlink" title="CCU request"></a>CCU request</h3><p>Purge methods (Invalidate or Delete by URL) currently available with this API by task type, as well as an estimated completion time, are as follows:</p>
<table>
<thead>
<tr>
<th style="text-align:left"><em>Action</em></th>
<th style="text-align:left"><em>Operation</em></th>
<th style="text-align:left"><em>API EndPoint</em></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Invalidate by URL</td>
<td style="text-align:left">POST</td>
<td style="text-align:left">/ccu/v3/invalidate/url/{network}</td>
</tr>
<tr>
<td style="text-align:left">Delete by URL</td>
<td style="text-align:left">POST</td>
<td style="text-align:left">/ccu/v3/delete/url/{network}</td>
</tr>
</tbody>
</table>
<p><strong>Invalidate by URL</strong><br>Request:<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST  <span class="meta-keyword">/ccu/</span>v3<span class="meta-keyword">/invalidate/</span>url/production</div><div class="line">Content-Type: application/<span class="class">json</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"objects"</span>: [</div><div class="line">        <span class="string">"http://www.example.com/graphics/picture.gif"</span>,</div><div class="line">        <span class="string">"http://www.site-example.com/graphics/picture.gif"</span>,</div><div class="line">        <span class="string">"http://www.example1.com/documents/brochure.pdf"</span> </div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Response：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"httpStatus"</span>: <span class="number">201</span>,</div><div class="line">    <span class="attr">"detail"</span>: <span class="string">"Request accepted."</span>,</div><div class="line">    <span class="attr">"estimatedSeconds"</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">"purgeId"</span>: <span class="string">"043f-4af0-843f-aaf0043faaf0"</span>,</div><div class="line">    <span class="attr">"supportId"</span>: <span class="string">"17PY1321286429616716-211907680"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Delete by URL</strong><br>Request:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">POST  /ccu/v3/<span class="keyword">delete</span>/<span class="keyword">url</span>/production</div><div class="line"><span class="keyword">Content</span>-<span class="keyword">Type</span>: application/<span class="keyword">json</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"objects"</span>: [</div><div class="line">        <span class="string">"http://www.example.com/graphics/picture.gif"</span>,</div><div class="line">        <span class="string">"http://www.site-example.com/graphics/picture.gif"</span>,</div><div class="line">        <span class="string">"http://www.example1.com/documents/brochure.pdf"</span></div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Response:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"httpStatus"</span>: <span class="number">201</span>,</div><div class="line">    <span class="attr">"detail"</span>: <span class="string">"Request accepted."</span>,</div><div class="line">    <span class="attr">"estimatedSeconds"</span>: <span class="number">5</span>,</div><div class="line">    <span class="attr">"purgeId"</span>: <span class="string">"043f-4af0-843f-aaf0043faaf0"</span>,</div><div class="line">    <span class="attr">"supportId"</span>: <span class="string">"17PY1321286429616716-211907680"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="Signing-API-request"><a href="#Signing-API-request" class="headerlink" title="Signing API request"></a>Signing API request</h3><p>The signature is the base64-encoding of the SHA–256 HMAC of the data to sign with the signing key.<br>You can get an <a href="https://github.com/akamai-open" target="_blank" rel="external">EdgeGrid Request Signature Module</a>.</p>
<h4 id="Signing-Key"><a href="#Signing-Key" class="headerlink" title="Signing Key"></a>Signing Key</h4><p>The signing key is derived from the client secret. The signing key is computed as the base64 encoding of the SHA–256 HMAC of the timestamp string (the field value included in the HTTP authorization header described above) with the client secret as the key.<br><img src="/img/CCU_V3_WorkFlow.jpg" alt="Akamai CCU V3 WorkFlow"></p>
<h4 id="Example-Data-to-Sign"><a href="#Example-Data-to-Sign" class="headerlink" title="Example Data to Sign"></a>Example Data to Sign</h4><p>Raw CCU v3 request:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/diagnostic-tools/<span class="built_in">v1</span>/locations</div></pre></td></tr></table></figure></p>
<p>the data to sign looks like this (\t represents a tab, line breaks added for readability):<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">GET<span class="symbol">\t</span>https<span class="symbol">\t</span>akaa-xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx.luna.akamaiapis.net<span class="symbol">\t</span></div><div class="line">/diagnostic-tools/v1/locations<span class="symbol">\t</span><span class="symbol">\t</span><span class="symbol">\t</span>EG1-HMAC-SHA256</div><div class="line">client_token=akab-xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx;</div><div class="line">access_token=akab-xxxxxxxxxxxxxxxx-xxxxxxxxxxxxxxxx;</div><div class="line">timestamp=20140402T18:05:06+0000;</div><div class="line">nonce=185f94eb-537c-4c01-b8cc-2fa5a06aee7f;</div></pre></td></tr></table></figure></p>
<h3 id="More-information"><a href="#More-information" class="headerlink" title="More information"></a>More information</h3><p><a href="https://developer.akamai.com/api/purge/ccu/overview.html" target="_blank" rel="external">https://developer.akamai.com/api/purge/ccu/overview.html</a><br><a href="https://developer.akamai.com/introduction/Client_Auth.html" target="_blank" rel="external">https://developer.akamai.com/introduction/Client_Auth.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Concept&quot;&gt;&lt;a href=&quot;#Concept&quot; class=&quot;headerlink&quot; title=&quot;Concept&quot;&gt;&lt;/a&gt;Concept&lt;/h2&gt;&lt;p&gt;Akamai是著名的CDN内容提供商。它提供了一套purge的API用于清空Edge Server上的缓存，使客户可以拿到最新的内容。目前在用的是CCU OPEN V2 API，主要是基于XML或JASON的一套REST API。通过调用它，会将相应的purge请求加入一个队列中，同时它也提供了query status的API用于查询purge请求的状态。一般情况下，从提交请求到请求执行完成需要4-7min。&lt;br&gt;这里想要介绍的是Akamai那边提供的V3版本的API，目前处于Beta阶段。最大的卖点就是Fast Purge - Featuring 5-second purge。&lt;br&gt;
    
    </summary>
    
    
      <category term="Akamai,Fast Purge" scheme="http://yoursite.com/tags/Akamai-Fast-Purge/"/>
    
  </entry>
  
</feed>
